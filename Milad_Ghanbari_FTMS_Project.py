# -*- coding: utf-8 -*-
"""Milad Ghanbari FTMS Project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15MYH3EPdxqmAbldH4jQKvrjVdhk4maLH
"""

import cv2
import numpy as np
import matplotlib.pyplot as plt
from google.colab import files

# Read the original image
img = cv2.imread("original_image.png")

# Convert the image to YUV color space
img_yuv = cv2.cvtColor(img, cv2.COLOR_BGR2YUV)
y, u, v = cv2.split(img_yuv)

# Define block size (32x32)
block_size = 32
height, width = y.shape

# Create an empty array for the compressed Y channel
compressed_y = np.zeros_like(y)

# Process each 32x32 block in the Y channel
for i in range(0, height, block_size):
    for j in range(0, width, block_size):
        # Extract a block
        block = y[i:i+block_size, j:j+block_size]

        # Apply DCT to the block
        block_dct = cv2.dct(np.float32(block))

        # Set low frequencies to zero (compression)
        compression_rate = 10 #Between 1 (min) and 15 (max)
        a = 16 - compression_rate
        for m in range(a, 16):
          for n in range(a, 16):
            block_dct[m, n] = 0

        # Apply inverse DCT to the block
        block_idct = cv2.idct(block_dct)

        # Update the compressed Y channel with the block
        compressed_y[i:i+block_size, j:j+block_size] = block_idct

# Create the YUV image with the compressed luminance component
img_compressed = cv2.merge([compressed_y.astype(np.uint8), u, v])

# Convert the image to a NumPy array
image_array = np.array(img_compressed)

# Flatten the NumPy array to get the binary data
binary_data = img_compressed.tobytes()

# Write binary data to the file
with open('compressed_image', 'wb') as bin_file:
    bin_file.write(binary_data)

# Read binary data from the file
with open('compressed_image', 'rb') as bin_file:
    binary_data = bin_file.read()

# Convert binary data to NumPy array
image_array = np.frombuffer(binary_data, dtype=np.uint8)

# Reshape the NumPy array to the original image shape
height, width = y.shape
image_array = image_array.reshape((height, width, 3))  # 3-channel image (BGR)

# Create a CV2 image from the NumPy array
img_decompressed = cv2.cvtColor(image_array, cv2.COLOR_YUV2BGR)

# Save the decompressed image to a file
cv2.imwrite("decompressed_image.png", img_decompressed)

# Function to calculate PSNR
def calculate_psnr(original, compressed):
    mse = np.mean((original - compressed) ** 2)
    psnr = 20 * np.log10(255 / np.sqrt(mse))
    return psnr

# Calculate PSNR between original and decompressed images
psnr_value = calculate_psnr(np.array(img), np.array(img_decompressed))
print("PSNR:", psnr_value)

# Display the original and decompressed images
plt.figure(figsize=(10, 5))
plt.imshow(y, cmap='gray')
plt.title('Original Y Channel')
plt.axis('off')
plt.show()

plt.figure(figsize=(10, 5))
plt.imshow(compressed_y, cmap='gray')
plt.title('Compressed Y Channel')
plt.axis('off')
plt.show()

plt.figure(figsize=(10, 5))
plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
plt.title('Original Image')
plt.axis('off')
plt.show()

plt.figure(figsize=(10, 5))
plt.imshow(cv2.cvtColor(img_decompressed, cv2.COLOR_BGR2RGB))
plt.title('Decompressed Image')
plt.axis('off')
plt.show()